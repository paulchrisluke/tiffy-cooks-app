---
alwaysApply: true
---
Cursor Rules for Tiffy App

## Core Architecture Principles

### 1. Composables First - Never Direct API Calls in Components
- **ALWAYS** create composables for data operations (`usePosts`, `useTeam`, `useAuth`)
- **NEVER** put `$fetch` or API endpoints directly in Vue components
- Composables handle: API calls, loading states, error handling, form validation
- Components only consume composable interfaces

### 2. Database Query Organization
- **ALWAYS** put database operations in `/server/database/queries/[domain].ts`
- **NEVER** put raw SQL or database calls in API endpoints
- Follow existing patterns: `getAllPosts`, `createPost`, `updatePost`, `deletePost`
- **ALWAYS** include proper error handling with `createError`
- **ALWAYS** include authorization checks (team membership, ownership)

### 3. API Endpoint Structure & File Naming
- **ALWAYS** use file-based routing with specific naming patterns:
  - `index.get.ts` - GET requests to collection endpoints (e.g., `/api/teams/[id]/posts`)
  - `index.post.ts` - POST requests to collection endpoints (e.g., `/api/teams/[id]/posts`)
  - `[id].get.ts` - GET requests to specific resource (e.g., `/api/teams/[id]/posts/[postId]`)
  - `[id].patch.ts` - PATCH requests to specific resource
  - `[id].delete.ts` - DELETE requests to specific resource
  - `[id].post.ts` - POST requests to specific resource
  - `action.post.ts` - Custom actions (e.g., `check-slug.post.ts`, `upload-image.post.ts`)
- **ALWAYS** validate request body with Zod schemas using `validateBody`
- **ALWAYS** require user session with `requireUserSession(event)`
- **ALWAYS** check team ownership with `validateTeamOwnership` or `isTeamMember`
- **ALWAYS** return consistent error responses
- **ALWAYS** use `getRouterParams(event)` or `getRouterParam(event, 'paramName')` for route parameters

### 3.1. Required Utility Functions & Import Paths

#### Authentication & Session Management
- `requireUserSession(event)` - **Global function from `nuxt-auth-utils`**
  - **Purpose**: Validates user session and returns authenticated user
  - **Returns**: `{ user: SanitizedUser }`
  - **Throws**: 401 error if no valid session
  - **Usage**: `const { user } = await requireUserSession(event)`

#### Route Parameter Extraction
- `getRouterParams(event)` - **Global function from `h3`**
  - **Purpose**: Extracts all route parameters as an object
  - **Returns**: `Record<string, string>` (e.g., `{ id: "123", postId: "456" }`)
  - **Usage**: `const { id, postId } = getRouterParams(event)`

- `getRouterParam(event, 'paramName')` - **Global function from `h3`**
  - **Purpose**: Extracts a specific route parameter
  - **Returns**: `string | undefined`
  - **Usage**: `const teamId = getRouterParam(event, 'id')`

#### Request Body Validation
- `validateBody(event, schema)` - **Import from `@@/server/utils/bodyValidation`**
  - **Purpose**: Validates request body against Zod schema
  - **Returns**: Parsed and validated data
  - **Throws**: 400 error with validation details if invalid
  - **Usage**: `const data = await validateBody(event, mySchema)`

#### Team Authorization
- `validateTeamOwnership(event, teamId)` - **Import from `@@/server/utils/teamValidation`**
  - **Purpose**: Validates user is owner of specified team
  - **Returns**: `{ user: SanitizedUser, team: Team }`
  - **Throws**: 400/403/404 errors for invalid team or insufficient permissions
  - **Usage**: `const { user, team } = await validateTeamOwnership(event, teamId)`

- `isTeamMember(teamId, userId)` - **Import from `@@/server/database/queries/teams`**
  - **Purpose**: Checks if user is a member of the team
  - **Returns**: `boolean`
  - **Throws**: 500 error on database failure
  - **Usage**: `const hasAccess = await isTeamMember(teamId, user.id)`

#### Error Handling
- `createError(options)` - **Import from `h3`**
  - **Purpose**: Creates standardized HTTP errors
  - **Returns**: Throws H3Error
  - **Usage**: `throw createError({ statusCode: 400, statusMessage: 'Invalid input' })`

### 3.2. Required Import Statements

Add these foundation imports to your API endpoint files:

```typescript
// For body validation
import { validateBody } from '@@/server/utils/bodyValidation'

// For team authorization
import { validateTeamOwnership } from '@@/server/utils/teamValidation'
import { isTeamMember } from '@@/server/database/queries/teams'

// For error handling
import { createError } from 'h3'

// Global functions (no import needed - provided by nuxt-auth-utils):
// - requireUserSession(event)
// - getRouterParams(event)
// - getRouterParam(event, 'paramName')
```

**Domain-specific imports** must be added per endpoint: import data operations from `@@/server/database/queries/[domain]` and validation schemas from `@@/shared/validations/[domain]` (e.g., `createPost` from `@@/server/database/queries/posts` and `createPostSchema` from `@@/shared/validations/posts`).

### 3.3. Complete API Endpoint Example

Here's a complete example showing all utilities working together:

```typescript
// server/api/teams/[id]/posts/index.post.ts
import { validateBody } from '@@/server/utils/bodyValidation'
import { validateTeamOwnership } from '@@/server/utils/teamValidation'
import { createPost } from '@@/server/database/queries/posts'
import { createError } from 'h3'
import { createPostSchema } from '@@/shared/validations/posts'

export default defineEventHandler(async (event) => {
  // 1. Extract route parameters
  const { id: teamId } = getRouterParams(event)

  // 2. Validate user session and team ownership
  const { user, team } = await validateTeamOwnership(event, teamId)

  // 3. Validate request body
  const data = await validateBody(event, createPostSchema)

  // 4. Create post with proper error handling
  try {
    const post = await createPost({
      ...data,
      teamId,
      authorId: user.id,
    })
    return post
  } catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: 'Failed to create post',
    })
  }
})
```

### 4. Form and Validation Patterns
- **ALWAYS** use Zod schemas for validation in both composables and API endpoints
- **ALWAYS** use `UForm` components with reactive state
- **ALWAYS** handle form submission in composables, not components
- **ALWAYS** show loading states and success/error toasts

### 5. File Upload Pattern
- **ALWAYS** use dedicated uploader components (`AvatarUploader`, `PostImageUploader`)
- **ALWAYS** handle file preview with `useObjectUrl`
- **ALWAYS** upload to `/api/upload-image` endpoint
- **ALWAYS** return image paths as `/images/{filename}`

### 6. State Management
- **ALWAYS** use `useState` for global state (teams, user session)
- **ALWAYS** use `ref` and `reactive` in composables for local state
- **ALWAYS** refresh data after mutations with `refresh()` or manual updates
- **NEVER** put business logic in components

### 7. Error Handling
- **ALWAYS** use `useToast()` for user feedback
- **ALWAYS** handle errors in composables with try/catch
- **ALWAYS** provide meaningful error messages
- **ALWAYS** log errors to console for debugging

### 8. Type Safety
- **ALWAYS** import types from `@@/types/database`
- **ALWAYS** use proper TypeScript interfaces
- **ALWAYS** type composable return values
- **ALWAYS** use Zod for runtime validation

### 9. Team-Based Architecture
- **ALWAYS** check team membership before data operations
- **ALWAYS** use `currentTeam` from `useTeam()` composable
- **ALWAYS** include `teamId` in database operations
- **ALWAYS** validate team ownership for sensitive operations

### 10. Code Organization
- **ALWAYS** keep files under 500 lines - split into folders if needed
- **ALWAYS** follow existing folder structure
- **ALWAYS** use consistent naming: `use[Domain]` for composables
- **ALWAYS** export functions from query files

## File Structure Rules

```
app/composables/          # Data layer - API calls, state, validation
server/database/queries/  # Database operations only
server/api/              # HTTP endpoints with validation
shared/validations/      # Shared Zod schemas
app/components/          # UI components only
```

## Server API File Naming Examples

### Collection Endpoints (CRUD operations on collections)
```
/api/teams/[id]/posts/
├── index.get.ts    → GET /api/teams/123/posts (get all posts)
└── index.post.ts   → POST /api/teams/123/posts (create new post)
```

### Resource Endpoints (CRUD operations on specific resources)
```
/api/teams/[id]/posts/[postId]/
├── [postId].get.ts    → GET /api/teams/123/posts/456 (get specific post)
├── [postId].patch.ts  → PATCH /api/teams/123/posts/456 (update post)
└── [postId].delete.ts → DELETE /api/teams/123/posts/456 (delete post)
```

### Custom Action Endpoints
```
/api/teams/
├── check-slug.post.ts → POST /api/teams/check-slug (custom action)
└── verify-invite.get.ts → GET /api/teams/verify-invite (custom action)

/api/
└── upload-image.post.ts → POST /api/upload-image (file upload)
```

### Nested Resource Examples
```
/api/teams/[id]/members/
├── index.get.ts        → GET /api/teams/123/members
├── index.post.ts       → POST /api/teams/123/members (invite member)
└── [memberId].delete.ts → DELETE /api/teams/123/members/456

/api/teams/[id]/invites/
├── index.get.ts           → GET /api/teams/123/invites
├── [inviteId].delete.ts   → DELETE /api/teams/123/invites/456
└── [inviteId]/resend.post.ts → POST /api/teams/123/invites/456/resend
```

## What NOT to Do

- ❌ Never put API calls in Vue components
- ❌ Never put database queries in API endpoints
- ❌ Never skip validation on API endpoints
- ❌ Never skip authorization checks
- ❌ Never put business logic in components
- ❌ Never create files over 500 lines without splitting
- ❌ Never duplicate existing functionality

## What TO Do

- ✅ Always create composables for data operations
- ✅ Always validate with Zod schemas
- ✅ Always check user permissions
- ✅ Always handle loading and error states
- ✅ Always use existing patterns as templates
- ✅ Always keep components focused on UI only
- ✅ Always follow the established folder structure
